"use strict";(globalThis.webpackChunkgeowebmap=globalThis.webpackChunkgeowebmap||[]).push([[2002],{76046:(t,e,n)=>{n.d(e,{Z:()=>b});var r,o=n(27366),i=n(46784),a=n(92026),s=n(49861),l=(n(63780),n(93169),n(25243),n(69912)),c=n(14226),u=n(81949),p=n(11186),f=n(71353),h=n(7882),g=n(79803),m=n(92183),d=n(45238),y=n(25158),x=n(32035),v=n(92770);let w=r=class extends i.wq{constructor(t){super(t),this.origin=(0,f.c)(),this.translation=(0,f.c)(),this.rotation=(0,d.Ue)(),this.scale=(0,f.f)(1,1,1),this.geographic=!0}get localMatrix(){const t=(0,u.c)();return(0,c.u)(t,this.scale),(0,c.e)(t,t,(0,d.WH)(this.rotation),(0,d.ZZ)(this.rotation)),(0,c.j)(t,t,this.translation),t}get localMatrixInverse(){return(0,c.a)((0,u.c)(),this.localMatrix)}applyLocal(t,e){return(0,p.m)(e,t,this.localMatrix)}applyLocalInverse(t,e){return(0,p.m)(e,t,this.localMatrixInverse)}project(t,e){const n=new Float64Array(t.length),r=y.fP.fromTypedArray(n),o=y.fP.fromTypedArray(t);if(this.geographic){const t=(0,m.rS)(e),i=(0,u.c)();return(0,g.Bm)(e,this.origin,i,t),(0,c.m)(i,i,this.localMatrix),(0,x.t)(r,o,i),(0,g.CM)(n,t,0,n,e,0,n.length/3),n}const{localMatrix:i,origin:a}=this;(0,c.v)(i,u.I)?(0,v.c)(r,o):(0,x.t)(r,o,i);for(let s=0;s<n.length;s+=3)n[s+0]+=a[0],n[s+1]+=a[1],n[s+2]+=a[2];return n}getOriginPoint(t){const[e,n,r]=this.origin;return new h.Z({x:e,y:n,z:r,spatialReference:t})}equals(t){return(0,a.pC)(t)&&this.geographic===t.geographic&&(0,p.k)(this.origin,t.origin)&&(0,c.w)(this.localMatrix,t.localMatrix)}clone(){const t={origin:(0,f.a)(this.origin),translation:(0,f.a)(this.translation),rotation:(0,d.Ue)(this.rotation),scale:(0,f.a)(this.scale),geographic:this.geographic};return new r(t)}};(0,o._)([(0,s.Cb)({type:[Number],nonNullable:!0,json:{write:!0}})],w.prototype,"origin",void 0),(0,o._)([(0,s.Cb)({type:[Number],nonNullable:!0,json:{write:!0}})],w.prototype,"translation",void 0),(0,o._)([(0,s.Cb)({type:[Number],nonNullable:!0,json:{write:!0}})],w.prototype,"rotation",void 0),(0,o._)([(0,s.Cb)({type:[Number],nonNullable:!0,json:{write:!0}})],w.prototype,"scale",void 0),(0,o._)([(0,s.Cb)({type:Boolean,nonNullable:!0,json:{write:!0}})],w.prototype,"geographic",void 0),(0,o._)([(0,s.Cb)()],w.prototype,"localMatrix",null),(0,o._)([(0,s.Cb)()],w.prototype,"localMatrixInverse",null),w=r=(0,o._)([(0,l.j)("esri.geometry.support.MeshTransform")],w);const b=w},45238:(t,e,n)=>{n.d(e,{Ue:()=>s,WH:()=>p,ZZ:()=>u,qC:()=>c,uT:()=>l});var r=n(16889),o=n(48976),i=n(98131),a=n(11186);function s(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:h;return[t[0],t[1],t[2],t[3]]}function l(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s();return(0,a.g)(n,t),n[3]=e,n}function c(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s();return(0,o.s)(g,t,p(t)),(0,o.s)(m,e,p(e)),(0,o.m)(g,m,g),f(n,(0,r.BV)((0,o.g)(n,g)))}function u(t){return t}function p(t){return(0,r.Vl)(t[3])}function f(t,e){return t[3]=e,t}const h=[0,0,1,0],g=(0,i.a)(),m=(0,i.a)();s()},26548:(t,e,n)=>{function r(t,e){var n;return t.isGeographic||t.isWebMercator&&(null==(n=null==e?void 0:e.geographic)||n)}n.d(e,{h:()=>r})},57898:(t,e,n)=>{n.d(e,{FF:()=>v,I5:()=>y,Yq:()=>w,iv:()=>d,w1:()=>x});var r=n(92026),o=n(68860),i=n(11873),a=n(14226),s=n(81949),l=n(22753),c=n(79803),u=n(92183),p=n(76046),f=n(25158),h=n(32035),g=n(26548),m=n(11700);function d(t,e,n){return(0,g.h)(e.spatialReference,n)?function(t,e,n){const r=e.spatialReference,o=F(e,n,T),i=new Float64Array(t.position.length),a=function(t,e,n,r){(0,h.t)(f.fP.fromTypedArray(r),f.fP.fromTypedArray(t),e);const o=new Float64Array(t.length);return(0,m.To)(r,o,n)}(t.position,o,r,i),s=(0,l.a)(O,o);return{position:a,normal:b(a,i,t.normal,s,r),tangent:A(a,i,t.tangent,s,r)}}(t,e,n):function(t,e,n){const r=new Float64Array(t.position.length),o=t.position,i=e.x,a=e.y,s=e.z||0,{horizontal:l,vertical:c}=E(n?n.unit:null,e.spatialReference);for(let u=0;u<o.length;u+=3)r[u+0]=o[u+0]*l+i,r[u+1]=o[u+1]*l+a,r[u+2]=o[u+2]*c+s;return{position:r,normal:t.normal,tangent:t.tangent}}(t,e,n)}function y(t,e,n){const{position:o,normal:i,tangent:a}=t;if((0,r.Wi)(e))return{position:o,normal:i,tangent:a};const s=e.localMatrix;return d({position:(0,m.zZ)(o,new Float64Array(o.length),s),normal:(0,r.pC)(i)?(0,m.w9)(i,new Float32Array(i.length),s):null,tangent:(0,r.pC)(a)?(0,m.VS)(a,new Float32Array(a.length),s):null},e.getOriginPoint(n),{geographic:e.geographic})}function x(t,e,n){if(null!=n&&n.useTransform){var r;const{position:o,normal:i,tangent:a}=t;return{vertexAttributes:{position:o,normal:i,tangent:a},transform:new p.Z({origin:[e.x,e.y,null!=(r=e.z)?r:0],geographic:(0,g.h)(e.spatialReference,n)})}}return{vertexAttributes:d(t,e,n),transform:null}}function v(t,e,n){return(0,g.h)(e.spatialReference,n)?R(t,e,n):C(t,e,n)}function w(t,e,n,o){if((0,r.Wi)(e))return v(t,n,o);const i=y(t,e,n.spatialReference);return n.equals(e.getOriginPoint(n.spatialReference))?C(i,n,o):(0,g.h)(n.spatialReference,o)?R(i,n,o):C(i,n,o)}function b(t,e,n,o,i){if((0,r.Wi)(n))return null;const a=new Float32Array(n.length);return(0,h.a)(f.ct.fromTypedArray(a),f.ct.fromTypedArray(n),o),(0,m.Yk)(a,t,e,i,a),a}function A(t,e,n,o,i){if((0,r.Wi)(n))return null;const a=new Float32Array(n.length);(0,h.a)(f.ct.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT),f.ct.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),o);for(let r=3;r<a.length;r+=4)a[r]=n[r];return(0,m.M2)(a,t,e,i,a),a}function C(t,e,n){const r=new Float64Array(t.position.length),o=t.position,i=e.x,a=e.y,s=e.z||0,{horizontal:l,vertical:c}=E(n?n.unit:null,e.spatialReference);for(let u=0;u<o.length;u+=3)r[u+0]=(o[u+0]-i)/l,r[u+1]=(o[u+1]-a)/l,r[u+2]=(o[u+2]-s)/c;return{position:r,normal:t.normal,tangent:t.tangent}}function R(t,e,n){const r=e.spatialReference;F(e,n,T);const o=(0,a.a)(P,T),i=new Float64Array(t.position.length),s=function(t,e,n,r){const o=(0,m.XO)(t,e,r),i=f.fP.fromTypedArray(o),a=new Float64Array(o.length),s=f.fP.fromTypedArray(a);return(0,h.t)(s,i,n),a}(t.position,r,o,i),c=(0,l.a)(O,o);return{position:s,normal:M(t.normal,t.position,i,r,c),tangent:Z(t.tangent,t.position,i,r,c)}}function F(t,e,n){(0,c.Bm)(t.spatialReference,[t.x,t.y,t.z||0],n,(0,u.rS)(t.spatialReference));const{horizontal:r,vertical:o}=E(e?e.unit:null,t.spatialReference);return(0,a.h)(n,n,[r,r,o]),n}function M(t,e,n,o,i){if((0,r.Wi)(t))return null;const a=(0,m.Iz)(t,e,n,o,new Float32Array(t.length)),s=f.ct.fromTypedArray(a);return(0,h.a)(s,s,i),a}function Z(t,e,n,o,i){if((0,r.Wi)(t))return null;const a=(0,m.wi)(t,e,n,o,new Float32Array(t.length)),s=f.ct.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT);return(0,h.a)(s,s,i),a}function E(t,e){if((0,r.Wi)(t))return I;const n=e.isGeographic?1:(0,o.Z7)(e),i=e.isGeographic?1:(0,o._R)(e),a=(0,o.En)(1,t,"meters");return{horizontal:a*n,vertical:a*i}}const T=(0,s.c)(),P=(0,s.c)(),O=(0,i.c)(),I={horizontal:1,vertical:1}},52002:(t,e,n)=>{n.r(e),n.d(e,{meshFeatureSetFromJSON:()=>Ot});var r=n(52639),o=n(92026),i=n(53866),a=n(27366),s=n(10064),l=n(41691),c=n(54472),u=n(32718),p=n(67426),f=n(66978),h=n(94172),g=n(49861),m=(n(63780),n(93169),n(25243),n(69912)),d=n(71353),y=n(32238),x=n(7882),v=n(80885),w=n(45238),b=n(64995),A=n(76046),C=n(27474),R=n(91320),F=n(79803),M=n(26548),Z=n(57898);const E=u.Z.getLogger("esri.geometry.support.meshUtils.centerAt");function T(t,e,n){var r;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const i=null!=(r=null==n?void 0:n.origin)?r:t.origin;(0,o.pC)(t.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&E.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e,n){const r=e.x-n.x,o=e.y-n.y,i=e.hasZ&&n.hasZ?e.z-n.z:0,a=t.origin;t.origin=[a[0]+r,a[1]+o,a[2]+i]}(t.transform,e,i)):(0,M.h)(t.spatialReference,n)?function(t,e,n){const r=(0,Z.FF)(t.vertexAttributes,n,{geographic:!0}),{position:o,normal:i,tangent:a}=(0,Z.iv)(r,e,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=i,t.vertexAttributes.tangent=a,t.vertexAttributesChanged()}(t,e,i):function(t,e,n){const r=O,o=P;if((0,F.KC)(e,o,t.spatialReference)){if(!(0,F.KC)(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,E.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function(t,e,n){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=e[o]-n[o]})(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else E.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,e,i)}const P=(0,d.c)(),O=(0,d.c)();var I=n(35995);function z(t){const e=(0,I.Yd)(t.url);return n=>{var r;const o=(0,I.PF)(n,e,e),i=o?o.replace(/^ *\.\//,""):null;return null!=(r=t.files.get(i))?r:n}}async function L(t,e){return t instanceof Blob?S.fromBlob(t):"string"==typeof t?new S(t):Array.isArray(t)?async function(t,e){const n=new Map;let r=null;const i=await(0,f.WW)(t.map((async t=>({name:t.name,source:await L(t instanceof Blob?t:t.source,e)})))),a=[];for(const o of i)o&&((0,f.Hc)(e)?o.source.dispose():a.push(o));(0,f.k_)(e);for(const{name:s,source:l}of a)((0,o.Wi)(r)||/\.(gltf|glb)/i.test(s))&&(r=l.url),n.set(s,l.url),l.files&&l.files.forEach(((t,e)=>n.set(e,t)));if((0,o.Wi)(r))throw new s.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new S(r,(()=>a.forEach((t=>{let{source:e}=t;return e.dispose()}))),n)}(t,e):async function(t,e){const{default:r}=await(0,f.Hl)(Promise.resolve().then(n.bind(n,76200)),e),o="string"==typeof t.multipart[0]?await Promise.all(t.multipart.map((async t=>(await r(t,{responseType:"array-buffer"})).data))):t.multipart;return S.fromBlob(new Blob(o))}(t,e)}class S{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map;this.url=t,this.dispose=e,this.files=n}static fromBlob(t){const e=URL.createObjectURL(t);return new S(e,(()=>URL.revokeObjectURL(e)))}}var N=n(22753),_=n(11873),U=n(81949),k=n(11186),D=n(92183),j=n(11700);const B=u.Z.getLogger("esri.geometry.support.meshUtils.offset");function W(t,e,n){t.vertexAttributes&&t.vertexAttributes.position&&((0,o.pC)(t.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&B.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e){const n=t.origin;t.origin=(0,k.b)((0,d.c)(),n,e)}(t.transform,e)):(0,M.h)(t.spatialReference,n)?function(t,e){const n=t.spatialReference,r=t.vertexAttributes.position,i=t.vertexAttributes.normal,a=t.vertexAttributes.tangent,s=new Float64Array(r.length),l=(0,o.pC)(i)?new Float32Array(i.length):null,c=(0,o.pC)(a)?new Float32Array(a.length):null,u=t.extent.center,p=$;(0,F.Bm)(n,[u.x,u.y,u.z],Y,(0,D.rS)(n)),(0,N.f)(q,Y),(0,k.t)(p,e,q),(0,j.XO)(r,n,s),(0,o.pC)(i)&&(0,j.Iz)(i,r,s,n,l),(0,o.pC)(a)&&(0,j.wi)(a,r,s,n,c),G(s,p),(0,j.To)(s,r,n),(0,o.pC)(i)&&(0,j.Yk)(l,r,s,n,i),(0,o.pC)(a)&&(0,j.M2)(c,r,s,n,a),t.vertexAttributesChanged()}(t,e):function(t,e){G(t.vertexAttributes.position,e),t.vertexAttributesChanged()}(t,e))}function G(t,e){if(t)for(let n=0;n<t.length;n+=3)for(let r=0;r<3;r++)t[n+r]+=e[r]}const $=(0,d.c)(),Y=(0,U.c)(),q=(0,_.c)();const H={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function K(t,e,n){(function(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5})(t),function(t,e){if(null==e)return;const n="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];Q[0]=n[0],Q[4]=n[1],Q[8]=n[2];for(let r=0;r<t.position.length;r+=3){for(let e=0;e<3;e++)J[e]=t.position[r+e];(0,k.t)(J,J,Q);for(let e=0;e<3;e++)t.position[r+e]=J[e]}if(n[0]!==n[1]||n[1]!==n[2]){Q[0]=1/n[0],Q[4]=1/n[1],Q[8]=1/n[2];for(let e=0;e<t.normal.length;e+=3){for(let n=0;n<3;n++)J[n]=t.normal[e+n];(0,k.t)(J,J,Q),(0,k.n)(J,J);for(let n=0;n<3;n++)t.normal[e+n]=J[n]}}}(t,n&&n.size);const{vertexAttributes:r,transform:o}=(0,Z.w1)(t,e,n);return{vertexAttributes:new C.Q({...r,uv:t.uv}),transform:o,components:[new b.Z({faces:t.faces,material:n&&n.material||null})],spatialReference:e.spatialReference}}const X={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},V={south:0,east:1,north:2,west:3,up:4,down:5},J=(0,d.c)(),Q=(0,_.c)();var tt=n(14226);const et=u.Z.getLogger("esri.geometry.support.meshUtils.rotate");function nt(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const r=t.spatialReference;if((0,o.pC)(t.transform)){var i;null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&et.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=null!=(i=null==n?void 0:n.origin)?i:t.transform.getOriginPoint(r);!function(t,e,n){const r=(0,k.s)(ot,n.x,n.y,n.z),o=(0,k.f)(ot,r,t.origin);t.applyLocalInverse(o,it),t.rotation=(0,w.qC)(t.rotation,e,(0,w.Ue)()),t.applyLocalInverse(o,o),(0,k.f)(o,o,it),t.translation=(0,k.b)((0,d.c)(),t.translation,o)}(t.transform,e,o)}else{var a;const r=null!=(a=null==n?void 0:n.origin)?a:t.origin;(0,M.h)(t.spatialReference,n)?function(t,e,n){const r=t.spatialReference,i=(0,D.rS)(r),a=ct;(0,F.KC)(n,a,i)||(0,F.KC)(t.origin,a,i);const s=t.vertexAttributes.position,l=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,u=new Float64Array(s.length),p=(0,o.pC)(l)?new Float32Array(l.length):null,f=(0,o.pC)(c)?new Float32Array(c.length):null;(0,F.Bm)(i,a,st,i),(0,N.f)(lt,st);const h=at;(0,k.t)((0,w.ZZ)(at),(0,w.ZZ)(e),lt),h[3]=e[3],(0,j.XO)(s,r,u),(0,o.pC)(l)&&(0,j.Iz)(l,s,u,r,p),(0,o.pC)(c)&&(0,j.wi)(c,s,u,r,f),rt(u,h,3,a),(0,j.To)(u,s,r),(0,o.pC)(l)&&(rt(p,h,3),(0,j.Yk)(p,s,u,r,l)),(0,o.pC)(c)&&(rt(f,h,4),(0,j.M2)(f,s,u,r,c)),t.vertexAttributesChanged()}(t,e,r):function(t,e,n){const r=ct;if(!(0,F.KC)(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,et.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}rt(t.vertexAttributes.position,e,3,r),rt(t.vertexAttributes.normal,e,3),rt(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}(t,e,r)}}function rt(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:d.Z;if(!(0,o.Wi)(t)){(0,tt.d)(st,(0,w.WH)(e),(0,w.ZZ)(e));for(let e=0;e<t.length;e+=n){for(let n=0;n<3;n++)ot[n]=t[e+n]-r[n];(0,k.m)(ot,ot,st);for(let n=0;n<3;n++)t[e+n]=ot[n]+r[n]}}}const ot=(0,d.c)(),it=(0,d.c)(),at=(0,w.Ue)(),st=(0,U.c)(),lt=(0,_.c)(),ct=(0,d.c)(),ut=u.Z.getLogger("esri.geometry.support.meshUtils.scale");function pt(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if((0,o.pC)(t.transform)){var i;null!=(null==n?void 0:n.geographic)&&n.geographic!==t.transform.geographic&&ut.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=null!=(i=null==n?void 0:n.origin)?i:t.transform.getOriginPoint(r);!function(t,e,n){const r=(0,k.s)(ht,n.x,n.y,n.z),o=(0,k.f)(ht,r,t.origin);t.applyLocalInverse(o,gt);const i=(0,k.a)((0,d.c)(),t.scale,e);t.scale=i,t.applyLocalInverse(o,o),(0,k.f)(o,o,gt),t.translation=(0,k.b)((0,d.c)(),t.translation,o)}(t.transform,e,o)}else{const r=(0,M.h)(t.spatialReference,n),i=n&&n.origin||t.origin;r?function(t,e,n){const r=t.spatialReference,i=(0,D.rS)(r),a=mt;(0,F.KC)(n,a,i)||(0,F.KC)(t.origin,a,i);const s=t.vertexAttributes.position,l=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,u=new Float64Array(s.length),p=(0,o.pC)(l)?new Float32Array(l.length):null,f=(0,o.pC)(c)?new Float32Array(c.length):null;(0,j.XO)(s,r,u),(0,o.pC)(l)&&(0,j.Iz)(l,s,u,r,p),(0,o.pC)(c)&&(0,j.wi)(c,s,u,r,f),ft(u,e,a),(0,j.To)(u,s,r),(0,o.pC)(l)&&(0,j.Yk)(p,s,u,r,l),(0,o.pC)(c)&&(0,j.M2)(f,s,u,r,c),t.vertexAttributesChanged()}(t,e,i):function(t,e,n){const r=mt;if(!(0,F.KC)(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,ut.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}ft(t.vertexAttributes.position,e,r),t.vertexAttributesChanged()}(t,e,i)}}function ft(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:d.Z;if(t)for(let r=0;r<t.length;r+=3){for(let e=0;e<3;e++)ht[e]=t[r+e]-n[e];(0,k.a)(ht,ht,e);for(let e=0;e<3;e++)t[r+e]=ht[e]+n[e]}}const ht=(0,d.c)(),gt=(0,d.c)(),mt=(0,d.c)();var dt;const yt=u.Z.getLogger("esri.geometry.Mesh");let xt=dt=class extends((0,l.p)(c.Z.LoadableMixin((0,p.v)(y.Z)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new C.Q,this.type="mesh"}initialize(){((0,o.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add((0,h.YP)((()=>{var t;return{vertexAttributes:this.vertexAttributes,components:null==(t=this.components)?void 0:t.map((t=>t.clone())),transform:(0,o.pC)(this.transform)?this.transform.clone():null}}),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&(0,o.pC)(this.external)&&(0,o.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,e=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new i.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e}),center:new x.Z({x:0,y:0,z:0,spatialReference:e})};const n=(0,o.pC)(this.transform)?this.transform.project(t,e):t;let r=1/0,a=1/0,s=1/0,l=-1/0,c=-1/0,u=-1/0,p=0,f=0,h=0;const g=n.length,m=1/(g/3);let d=0;for(;d<g;){const t=n[d++],e=n[d++],o=n[d++];r=Math.min(r,t),a=Math.min(a,e),s=Math.min(s,o),l=Math.max(l,t),c=Math.max(c,e),u=Math.max(u,o),p+=m*t,f+=m*e,h+=m*o}return{extent:new i.Z({xmin:r,ymin:a,zmin:s,xmax:l,ymax:c,zmax:u,spatialReference:e}),center:new x.Z({x:p,y:f,z:h,spatialReference:e})}}get anchor(){if((0,o.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new x.Z({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,o.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&(0,o.pC)(this.external)&&(0,o.pC)(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(b.Z.from(t)),this.notifyChange("components")):yt.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}yt.error("removeComponent()","Provided component is not part of the list of components")}else yt.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,n,r){return(0,w.uT)(vt.x,t,wt),(0,w.uT)(vt.y,e,bt),(0,w.uT)(vt.z,n,At),(0,w.qC)(wt,bt,wt),(0,w.qC)(wt,At,wt),nt(this,wt,r),this}offset(t,e,n,r){return this.loaded?(Ct[0]=t,Ct[1]=e,Ct[2]=n,W(this,Ct,r),this):(yt.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(pt(this,t,e),this):(yt.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(T(this,t,e),this):(yt.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return(0,o.pC)(this.external)&&this.addResolvingPromise(async function(t,e,r){const{loadGLTFMesh:i}=await(0,f.Hl)(n.e(5886).then(n.bind(n,35886)),r),a=await L(e,r),s=i(new x.Z({x:0,y:0,z:0,spatialReference:t.spatialReference}),a.url,{resolveFile:z(a),useTransform:!0,signal:(0,o.pC)(r)?r.signal:null});s.then((()=>a.dispose()),(()=>a.dispose()));const{vertexAttributes:l,components:c}=await s;t.vertexAttributes=l,t.components=c}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,e=this.components?new Map:null,n={components:this.components?this.components.map((n=>n.cloneWithDeduplication(t,e))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,o.pC)(this.transform)?this.transform.clone():null,external:(0,o.pC)(this.external)?{source:this.external.source,extent:(0,o.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new dt(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await n.e(1553).then(n.bind(n,11553));return e(this,t)}static createBox(t,e){if(!(t instanceof x.Z))return yt.error(".createBox()","expected location to be a Point instance"),null;const n=new dt(K(function(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=X,r=4*t.length,o=new Float64Array(3*r),i=new Float32Array(3*r),a=new Float32Array(2*r),s=new Uint32Array(2*t.length*3);let l=0,c=0,u=0,p=0;for(let f=0;f<t.length;f++){const r=t[f],h=l/3;for(const t of e)s[p++]=h+t;const g=r.corners;for(let t=0;t<4;t++){const e=g[t];let s=0;a[u++]=.25*n[t][0]+r.uvOrigin[0],a[u++]=r.uvOrigin[1]-.25*n[t][1];for(let t=0;t<3;t++)0!==r.axis[t]?(o[l++]=.5*r.axis[t],i[c++]=r.axis[t]):(o[l++]=.5*e[s++],i[c++]=0)}}return{position:o,normal:i,uv:a,faces:s}}(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?function(t,e){const n=t.components[0],r=n.faces,i=V[e],a=6*i,s=new Uint32Array(6),l=new Uint32Array(r.length-6);let c=0,u=0;for(let o=0;o<r.length;o++)o>=a&&o<a+6?s[c++]=r[o]:l[u++]=r[o];if((0,o.pC)(t.vertexAttributes.uv)){const e=new Float32Array(t.vertexAttributes.uv),n=4*i*2,r=[0,1,1,1,1,0,0,0];for(let t=0;t<r.length;t++)e[n+t]=r[t];t.vertexAttributes.uv=e}return t.components=[new b.Z({faces:s,material:n.material}),new b.Z({faces:l})],t}(n,e.imageFace):n}static createSphere(t,e){return t instanceof x.Z?new dt(K(function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const e=Math.round(8*2**t),n=2*e,r=(e-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),a=new Float32Array(2*r),s=new Uint32Array((e-1)*n*2*3);let l=0,c=0,u=0,p=0;for(let f=0;f<=e;f++){const t=f/e*Math.PI+.5*Math.PI,r=Math.cos(t),h=Math.sin(t);J[2]=h;const g=0===f||f===e,m=g?n-1:n;for(let d=0;d<=m;d++){const t=d/m*2*Math.PI;J[0]=-Math.sin(t)*r,J[1]=Math.cos(t)*r;for(let e=0;e<3;e++)o[l]=.5*J[e],i[l]=J[e],++l;a[c++]=(d+(g?.5:0))/n,a[c++]=f/e,0!==f&&d!==n&&(f!==e&&(s[u++]=p,s[u++]=p+1,s[u++]=p-n),1!==f&&(s[u++]=p,s[u++]=p-n,s[u++]=p-n-1)),p++}}return{position:o,normal:i,uv:a,faces:s}}(e&&e.densificationFactor||0),t,e)):(yt.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof x.Z?new dt(K(function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const e=5,n=Math.round(16*2**t),r=(e-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),a=new Float32Array(2*r),s=new Uint32Array(4*n*3);let l=0,c=0,u=0,p=0,f=0;for(let h=0;h<=e;h++){const t=0===h||h===e,r=h<=1||h>=e-1,g=2===h||4===h,m=t?n-1:n;for(let d=0;d<=m;d++){const y=d/m*2*Math.PI,x=t?0:.5;J[0]=x*Math.sin(y),J[1]=x*-Math.cos(y),J[2]=h<=2?.5:-.5;for(let t=0;t<3;t++)o[l++]=J[t],i[c++]=r?2===t?h<=1?1:-1:0:2===t?0:J[t]/x;a[u++]=(d+(t?.5:0))/n,a[u++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,g||0===h||d===n||(h!==e&&(s[p++]=f,s[p++]=f+1,s[p++]=f-n),1!==h&&(s[p++]=f,s[p++]=f-n,s[p++]=f-n-1)),f++}}return{position:o,normal:i,uv:a,faces:s}}(e&&e.densificationFactor||0),t,e)):(yt.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){var n;if(!(t instanceof x.Z))return yt.error(".createPlane()","expected location to be a Point instance"),null;const r=null!=(n=null==e?void 0:e.facing)?n:"up",o=function(t,e){const n="number"==typeof e?e:null!=e?e.width:1,r="number"==typeof e?e:null!=e?e.height:1;switch(t){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}(r,null==e?void 0:e.size);return new dt(K(function(t){const e=H.facingAxisOrderSwap[t],n=H.position,r=H.normal,o=new Float64Array(n.length),i=new Float32Array(r.length);let a=0;for(let s=0;s<4;s++){const t=a;for(let s=0;s<3;s++){const l=e[s],c=Math.abs(l)-1,u=l>=0?1:-1;o[a]=n[t+c]*u,i[a]=r[t+c]*u,a++}}return{position:o,normal:i,uv:new Float32Array(H.uv),faces:new Uint32Array(H.faces)}}(r),t,{...e,size:o}))}static createFromPolygon(t,e){if(!(t instanceof v.Z))return yt.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=(0,R.bT)(t);return new dt({vertexAttributes:new C.Q({position:n.position}),components:[new b.Z({faces:n.faces,shading:"flat",material:e&&e.material||null})],spatialReference:t.spatialReference})}static async createFromGLTF(t,e,r){if(!(t instanceof x.Z))throw yt.error(".createfromGLTF()","expected location to be a Point instance"),new s.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await(0,f.Hl)(n.e(5886).then(n.bind(n,35886)),r);return new dt(await o(t,e,r))}static createWithExternalSource(t,e,n){var r,o,i;const a=null!=(r=null==n?void 0:n.extent)?r:null,s=null!=(o=null==n?void 0:n.transform.clone())?o:new A.Z;s.origin=[t.x,t.y,null!=(i=t.z)?i:0];const l=t.spatialReference;return new dt({external:{source:e,extent:a},transform:s,spatialReference:l})}static createIncomplete(t,e){var n,r;const o=null!=(n=null==e?void 0:e.transform.clone())?n:new A.Z;o.origin=[t.x,t.y,null!=(r=t.z)?r:0];const i=t.spatialReference,a=new dt({transform:o,spatialReference:i});return a.addResolvingPromise(Promise.reject(new s.Z("mesh-incomplete","Mesh resources are not complete"))),a}};(0,a._)([(0,g.Cb)({type:[b.Z],json:{write:!0}})],xt.prototype,"components",void 0),(0,a._)([(0,g.Cb)({type:A.Z,json:{write:!0}})],xt.prototype,"transform",void 0),(0,a._)([(0,g.Cb)({constructOnly:!0})],xt.prototype,"external",void 0),(0,a._)([(0,g.Cb)({readOnly:!0})],xt.prototype,"hasExtent",null),(0,a._)([(0,g.Cb)({readOnly:!0})],xt.prototype,"boundingInfo",null),(0,a._)([(0,g.Cb)({readOnly:!0})],xt.prototype,"anchor",null),(0,a._)([(0,g.Cb)({readOnly:!0})],xt.prototype,"origin",null),(0,a._)([(0,g.Cb)({readOnly:!0,json:{read:!1}})],xt.prototype,"extent",null),(0,a._)([(0,g.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],xt.prototype,"hasZ",void 0),(0,a._)([(0,g.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],xt.prototype,"hasM",void 0),(0,a._)([(0,g.Cb)({type:C.Q,nonNullable:!0,json:{write:!0}})],xt.prototype,"vertexAttributes",void 0),xt=dt=(0,a._)([(0,m.j)("esri.geometry.Mesh")],xt);const vt={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},wt=(0,w.Ue)(),bt=(0,w.Ue)(),At=(0,w.Ue)(),Ct=(0,d.c)(),Rt=xt;var Ft,Mt,Zt;(Zt=Ft||(Ft={})).featureGUID="featureGUID",Zt.assetName="assetName",Zt.hash="hash",Zt.type="type",Zt.conversionStatus="conversionStatus",Zt.flags="flags",Zt.complexity="complexity",Zt.size="size",Zt.seqNo="seqNo",Zt.sourceHash="sourceHash",Zt.assetURL="assetURL",function(t){t.SUBMITTED="SUBMITTED",t.INPROGRESS="INPROGRESS",t.FAILED="FAILED",t.COMPLETED="COMPLETED"}(Mt||(Mt={}));var Et,Tt,Pt=n(49818);function Ot(t,e,n){const i=n.features;n.features=[],delete n.geometryType;const a=Pt.default.fromJSON(n);a.geometryType="mesh";const s=a.spatialReference,l=(0,o.Wi)(t.outFields)||!t.outFields.length?()=>({}):(c=t.outFields.includes("*")?null:new Set(t.outFields),t=>{let{attributes:e}=t;if(!e)return{};if(!c)return e;for(const n in e)c.has(n)||delete e[n];return e});var c;for(const u of i){const t=It(u,s,e);(0,o.pC)(t)&&a.features.push(new r.Z({geometry:t,attributes:l(u)}))}return a}function It(t,e,n){const{status:r,source:o}=function(t){if(!t.assetMappings)return{status:Et.FAILED};const e=[],n=new Map;for(const r of t.assetMappings){const t=r[Ft.seqNo],o=r[Ft.assetName],i=r[Ft.assetURL],a=r[Ft.conversionStatus];if(a===Mt.FAILED)return{status:Et.FAILED};if(a!==Mt.COMPLETED)return{status:Et.PENDING};if(null==t)e.push({name:o,source:i});else{const r=n.get(o);let a;r?a=r.multipart:(a=[],e.push({name:o,source:{multipart:a}}),n.set(o,{multipart:a})),a[t]=i}}return{status:Et.COMPLETED,source:e}}(t);if(r===Et.FAILED)return null;const a=function(t,e,n){let{attributes:r}=t,{transformFieldRoles:o}=n;return new x.Z({x:r[o.originX],y:r[o.originY],z:r[o.originZ],spatialReference:e})}(t,e,n),s=i.Z.fromJSON(t.geometry);s.spatialReference=e;const l=function(t,e){let{attributes:n,assetMappings:r}=t,{transformFieldRoles:o}=e;var i;return new A.Z({translation:[n[o.translationX],n[o.translationY],n[o.translationZ]],rotation:(0,w.uT)([n[o.rotationX],n[o.rotationY],n[o.rotationZ]],n[o.rotationDeg]),scale:[n[o.scaleX],n[o.scaleY],n[o.scaleZ]],geographic:!(null!=(i=r[Ft.flags])&&i.includes("PROJECT_VERTICES"))})}(t,n);return r===Et.PENDING?Rt.createIncomplete(a,{extent:s,transform:l}):Rt.createWithExternalSource(a,o,{extent:s,transform:l})}(Tt=Et||(Et={}))[Tt.FAILED=0]="FAILED",Tt[Tt.PENDING=1]="PENDING",Tt[Tt.COMPLETED=2]="COMPLETED"}}]);
//# sourceMappingURL=2002.1a10e205.chunk.js.map